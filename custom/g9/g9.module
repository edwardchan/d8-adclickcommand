<?php

/**
 * @file
 * Contains g9.module.
 */

use Drupal\Core\Routing\RouteMatchInterface;
use Drupal\node\NodeInterface;
use Drupal\pathauto\Entity\PathautoPattern;
use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Form\FormStateInterface;

/**
 * Implements hook_help().
 */
function g9_help($route_name, RouteMatchInterface $route_match) {
  switch ($route_name) {
    // Main module help for the util module.
    case 'help.page.g9':
      $output = '';
      $output .= '<h3>' . t('About') . '</h3>';
      $output .= '<p>' . t('Utility functions') . '</p>';
      return $output;

    default:
  }
}

/**
 * Implements hook_ENTITY_TYPE_presave().
 */
function g9_node_presave(NodeInterface $node) {
  // On nodes of type 'article' and 'web ad template', add the branded term to
  // the flags field if the field_sponsor has a value and vice versa.
  if (in_array($node->bundle(), ['article', 'web_ad_template']) && $node->hasField('field_sponsor') && $node->hasField('field_flags')) {
    // Find the ID of the term "Branded".
    $terms = taxonomy_term_load_multiple_by_name('Branded', 'flags');
    if (empty($terms)) {
      // If the term does not exist, there is no need to proceed.
      return;
    }
    $keys = array_keys($terms);
    $branded_term_id = array_shift($keys);

    /** @var Drupal\Core\Field\EntityReferenceFieldItemList $flag_field */
    $flag_field = &$node->field_flags;
    $flags = $flag_field->getValue();

    $is_branded = !empty($node->field_sponsor->getValue());
    if ($is_branded) {
      // Add the Branded term if it doesn't already exist.
      $branded_set = FALSE;
      foreach ($flags as $flag) {
        if ($flag['target_id'] == $branded_term_id) {
          $branded_set = TRUE;
          break;
        }
      }
      if (!$branded_set) {
        $flag_field->appendItem($branded_term_id);
      }
    }
    else {
      // Remove the Branded term.
      foreach ($flags as $position => $flag) {
        if ($flag['target_id'] == $branded_term_id) {
          $flag_field->removeItem($position);
        }
      }
    }
  }
}

/**
 * Alter the pattern to be used before an alias is generated by Pathauto.
 *
 * This hook will only be called if a default pattern is configured (on
 * admin/config/search/path/patterns).
 *
 * @param \Drupal\pathauto\Entity\PathautoPattern $pattern
 *   The alias pattern for Pathauto to pass to token_replace() to generate the
 *   URL alias.
 * @param array $context
 *   An associative array of additional options, with the following elements:
 *   - 'module': The module or entity type being aliased.
 *   - 'op': A string with the operation being performed on the object being
 *     aliased. Can be either 'insert', 'update', 'return', or 'bulkupdate'.
 *   - 'source': A string of the source path for the alias (e.g. 'node/1').
 *   - 'data': An array of keyed objects to pass to token_replace().
 *   - 'type': The sub-type or bundle of the object being aliased.
 *   - 'language': A string of the language code for the alias (e.g. 'en').
 *     This can be altered by reference.
 */
function g9_pathauto_pattern_alter(PathautoPattern &$pattern, array $context) {
  // When nodes are created or updated, alter pattern with criteria logic.
  if ($context['module'] == 'node' && ($context['op'] == 'insert' || $context['op'] == 'update')) {

    /** @var \Drupal\node\Entity\Node $node */
    $node = $context['data']['node'];

    $replacements = [];

    switch ($node->getType()) {
      // Article URL logic.
      case 'article':
        // Check with company is associated with the article.
        $companies = $node->get('field_brand')->referencedEntities();

        /** @var \Drupal\taxonomy\TermInterface $company */
        foreach ($companies as $company) {
          switch ($company->getName()) {
            case 'Thrillist':
              $primary_vertical = $node->get('field_primary_vertical')
                ->referencedEntities();
              if ($primary_vertical) {
                $replacements[] = '[node:field_primary_vertical:entity:name]';
              }

              $relevance = $node->get('field_relevance')
                ->first()
                ->get('entity')
                ->getTarget()
                ->getValue();
              if ($relevance) {
                $storage = \Drupal::service('entity_type.manager')
                  ->getStorage('taxonomy_term');
                $cleaner = \Drupal::service('pathauto.alias_cleaner');

                /** @var \Drupal\taxonomy\TermStorage $parents */
                $parents = $storage->loadParents($relevance->id());
                foreach ($parents as $parent) {
                  $replacements[] = $cleaner->cleanString($parent->getName());
                }
                $replacements[] = $cleaner->cleanString($relevance->getName());
                $replacements[] = $relevance->get('field_zipcode')->value;
              }

              $field_path = $node->get('field_path')->value;
              if ($field_path) {
                $replacements[] = '[node:field_path]';
              }
              else {
                $metatag_manager = \Drupal::service('metatag.manager');
                $metatags = $metatag_manager->tagsFromEntity($node);
                if (!empty($metatags['title'])) {
                  $replacements[] = '[node:seo_title]';
                }
                else {
                  $replacements[] = '[node:title]';
                }
              }
              break;

            case 'Supercall':
              $spirit = $node->get('field_spirits')->referencedEntities();
              if ($spirit) {
                $replacements[] = 'spirits';
                $replacements[] = '[node:field_spirits:entity:name]';
              }
              else {
                $primary_vertical = $node->get('field_primary_vertical')
                  ->referencedEntities();
                if ($primary_vertical) {
                  $data = ['node' => $node];
                  $token_service = \Drupal::service('token');

                  if ($token_service->replace('[node:field_primary_vertical:entity:name]', $data) <> 'Spirits') {
                    $replacements[] = '[node:field_primary_vertical:entity:name]';
                  }
                }

                $field_path = $node->get('field_path')->value;
                if ($field_path) {
                  $replacements[] = '[node:field_path]';
                }
                else {
                  $metatag_manager = \Drupal::service('metatag.manager');
                  $metatags = $metatag_manager->tagsFromEntity($node);
                  if (!empty($metatags['title'])) {
                    $replacements[] = '[node:seo_title]';
                  }
                  else {
                    $replacements[] = '[node:title]';
                  }
                }
              }
              break;

            default:
              break;
          }
        }
        break;

      case 'bar':
        // Bar URL logic.
        $field_path = $node->get('field_path')->value;
        if ($field_path) {
          $replacements[] = '[node:field_path]';
        }
        else {
          $metatag_manager = \Drupal::service('metatag.manager');
          $metatags = $metatag_manager->tagsFromEntity($node);
          if (!empty($metatags['title'])) {
            $replacements[] = '[node:seo_title]';
          }
          else {
            $replacements[] = '[node:title]';
          }
        }
        break;

      case 'checklist':
        // Checklist URL logic.
        $primary_vertical = $node->get('field_primary_vertical')
          ->referencedEntities();
        if ($primary_vertical) {
          $replacements[] = '[node:field_primary_vertical:entity:name]';

          $relevance = $node->get('field_relevance')->first();
          if (!empty($relevance)) {
            $relevance = $relevance
              ->get('entity')
              ->getTarget()
              ->getValue();
            if ($relevance) {
              $terms = \Drupal::service('entity_type.manager')
                ->getStorage('taxonomy_term')
                ->loadTree($relevance->getVocabularyId(), $relevance->id());

              $cleaner = \Drupal::service('pathauto.alias_cleaner');

              // It is a parent since it has children.
              if (!empty($terms)) {
                $replacements[] = $cleaner->cleanString($relevance->getName());
              }
              else {
                /** @var \Drupal\taxonomy\TermStorage $parents */
                $parents = \Drupal::service('entity_type.manager')
                  ->getStorage('taxonomy_term')
                  ->loadParents($relevance->id());
                foreach ($parents as $parent) {
                  $replacements[] = $cleaner->cleanString($parent->getName());
                }
              }
            }
          }

          $field_path = $node->get('field_path')->value;
          if ($field_path) {
            $replacements[] = '[node:field_path]-[node:nid]';
          }
          else {
            $metatag_manager = \Drupal::service('metatag.manager');
            $metatags = $metatag_manager->tagsFromEntity($node);
            if (!empty($metatags['title'])) {
              $replacements[] = '[node:seo_title]-[node:nid]';
            }
            else {
              $replacements[] = '[node:title]-[node:nid]';
            }
          }
        }
        else {
          $replacements[] = 'maps';
          $relevance = $node->get('field_relevance')->first();
          if (!empty($relevance)) {
            $relevance = $relevance
              ->get('entity')
              ->getTarget()
              ->getValue();
            if ($relevance) {
              /** @var \Drupal\taxonomy\TermStorage $parents */
              $terms = \Drupal::service('entity_type.manager')
                ->getStorage('taxonomy_term')
                ->loadTree($relevance->getVocabularyId(), $relevance->id());

              $cleaner = \Drupal::service('pathauto.alias_cleaner');

              // It is a parent since it has children.
              if (!empty($terms)) {
                $replacements[] = $cleaner->cleanString($relevance->getName());
              }
              else {
                /** @var \Drupal\taxonomy\TermStorage $parents */
                $parents = \Drupal::service('entity_type.manager')
                  ->getStorage('taxonomy_term')
                  ->loadParents($relevance->id());
                foreach ($parents as $parent) {
                  $replacements[] = $cleaner->cleanString($parent->getName());
                }
              }
            }
          }
          $replacements[] = '[node:title]-[node:nid]';
        }
        break;

      case 'recipe':
        // Recipe URL logic.
        $field_path = $node->get('field_path')->value;
        if ($field_path) {
          $replacements[] = '[node:field_path]';
        }
        else {
          $metatag_manager = \Drupal::service('metatag.manager');
          $metatags = $metatag_manager->tagsFromEntity($node);
          if (!empty($metatags['title'])) {
            $replacements[] = '[node:seo_title]';
          }
          else {
            $replacements[] = '[node:title]';
          }
        }
        break;

      case 'supercall_product':
        $brand = $node->get('field_brands')->referencedEntities();
        if ($brand) {
          $replacements[] = '[node:field_brands:entity:name]';
        }

        $metatag_manager = \Drupal::service('metatag.manager');
        $metatags = $metatag_manager->tagsFromEntity($node);
        if (!empty($metatags['title'])) {
          $replacements[] = '[node:seo_title]';
        }
        else {
          $replacements[] = '[node:title]';
        }
        break;

      case 'venue':
        // Venue URL logic to build <drink_or_eat_slug>.
        $primary_verticals = $node->get('field_primary_vertical')
          ->referencedEntities();

        $drink_or_eat_slug = [];
        $types = [];

        /** @var \Drupal\taxonomy\TermInterface $primary_vertical */
        foreach ($primary_verticals as $primary_vertical) {
          switch ($primary_vertical->getName()) {
            case 'Drink':
              $drink_or_eat_slug[] = '[node:field_primary_vertical:entity:name]';
              $types[] = 'bars';
              break;

            case 'Eat':
              $drink_or_eat_slug[] = '[node:field_primary_vertical:entity:name]';
              $types[] = 'restaurants';
              break;

            default:
              break;

          }
        }

        $edition = $node->get('field_edition')->referencedEntities();
        if ($edition) {
          $drink_or_eat_slug[] = '[node:field_edition:entity:name]';
        }

        if ($types) {
          $drink_or_eat_slug[] = implode('/', $types);
        }

        if (!$drink_or_eat_slug) {
          // Venue URL logic to build <nation_or_other_slug>.
          $nation_or_other_slug = [];
          $slug_str = '[node:title]';

          $zipcode = $node->get('field_zip_code')->value;
          if ($zipcode) {
            $slug_str .= '-[node:field_zip_code]';
          }

          $nation_or_other_slug[] = $slug_str;
          $replacements[] = implode('/', $nation_or_other_slug);
        }
        else {
          $replacements[] = implode('/', $drink_or_eat_slug);
        }

        break;

      case 'video':
        // Video URL logic.
        $primary_vertical = $node->get('field_primary_vertical')
          ->referencedEntities();
        if ($primary_vertical) {
          $replacements[] = '[node:field_primary_vertical:entity:name]';
        }

        $edition = $node->get('field_edition')->referencedEntities();
        if ($edition) {
          $replacements[] = '[node:field_edition:entity:name]';
        }

        $field_path = $node->get('field_path')->value;
        if ($field_path) {
          $replacements[] = '[node:field_path]-[node:nid]';
        }
        else {
          $metatag_manager = \Drupal::service('metatag.manager');
          $metatags = $metatag_manager->tagsFromEntity($node);
          if (!empty($metatags['title'])) {
            $replacements[] = '[node:seo_title]-[node:nid]';
          }
          else {
            $replacements[] = '[node:title]-[node:nid]';
          }
        }
        break;

      default:
        break;
    }

    if ($replacements) {

      // Split the replacements with slashes for URL.
      $replacements = implode('/', $replacements);

      // Replace default [node:title] with logic-derived tokens.
      $pattern->setPattern(preg_replace('/\[node:title(\:[^]]*)?\]/', $replacements . '$1', $pattern->getPattern()));
    }
  }
}

/**
 * Implements hook_library_info().
 */
function g9_library_info() {
  $libraries = [];

  $libraries['editorial.icons'] = [
    'title' => 'Editorial icon styling',
    'version' => '0.1',
    'css' => [
      drupal_get_path('module', 'g9') . '/css/editorial.icons.css' => [],
    ],
  ];

  return $libraries;
}

/**
 * Implements hook_toolbar().
 */
function g9_toolbar() {
  $items = [];

  $items['g9'] = [
    '#type' => 'toolbar_item',
    '#attached' => [
      'library' => [
        'g9/editorial.icons',
      ],
    ],
  ];

  return $items;
}

/**
 * Implements hook_token_info().
 */
function g9_token_info() {
  $info['tokens']['node']['seo_title'] = [
    'name' => t('SEO Title from Metatag configuration'),
    'description' => t('Custom token created for accessing SEO Title from Metatag.'),
  ];

  return $info;
}

/**
 * Implements hook_tokens().
 */
function g9_tokens($type, $tokens, array $data = [], array $options = []) {
  $replacements = [];

  if ($type == 'node' && !empty($data['node'])) {
    $node = $data['node'];

    foreach ($tokens as $name => $original) {
      switch ($name) {
        case 'seo_title':
          $to_replace = get_value_from_metatag($node, 'title');
          $replacements[$original] = $to_replace;
          break;
      }
    }
  }
  return $replacements;
}

/**
 * Utility function to grab SEO title from Metatag configuration.
 *
 * @param Drupal\Core\Entity\EntityInterface $entity
 *   The entity, typically a node or term object.
 * @param string $field
 *   The field to lookup on Metatag data.
 *
 * @return string
 *   The value stored on the field.
 */
function get_value_from_metatag(EntityInterface $entity, $field) {
  $metatag_manager = \Drupal::service('metatag.manager');
  $metatags = $metatag_manager->tagsFromEntity($entity);
  if (!empty($metatags[$field])) {
    return $metatags[$field];
  }
}

/**
 * Implements hook_form_alter().
 */
function g9_form_node_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  // Get the node object from the form.
  $node = $form_state->getFormObject()->getEntity();
  // Get all the enabled types from the 'Highlight' configuration page.
  $enabled_types = \Drupal::config('g9.highlight.settings')->get('enabled');
  // Filter out only the checked content types.
  $enabled_types = array_filter($enabled_types);

  // If the form has a 'field_highlight', but is not enabled, remove access
  // to the field. The field will be hidden on the content type until it is
  // enabled.
  if (isset($form['field_highlight']) && !in_array($node->getType(), $enabled_types)) {
    $form['field_highlight']['#access'] = FALSE;
  }

  $taxonomy_mapping = [];
  $fields = \Drupal::entityManager()->getFieldDefinitions('node', $node->getType());
  foreach ($fields as $field_name => $field_definition) {
    $target_type = $field_definition->getSetting('target_type');
    if ($target_type == 'taxonomy_term') {
      $handler = $field_definition->getSetting('handler_settings');
      if (isset($handler['view']) && isset($handler['view']['arguments'])) {
        $target_bundles = $handler['view']['arguments'];

        if (count($target_bundles) == 1) {
          $bundle = reset($target_bundles);
          $taxonomy_mapping[$bundle] = $field_name;
        }
      }
    }
  }

  $brand_mapping = [];
  $vertical_config = \Drupal::config('g9.vertical.settings')->get('vertical_mapping');
  if ($vertical_config) {
    foreach ($vertical_config as $key => $target_vocab) {
      if (isset($taxonomy_mapping[$target_vocab])) {
        $brand_mapping[$key] = $taxonomy_mapping[$target_vocab];
      }
    }
  }

  $form['#attached']['library'][] = 'g9/vertical-node-form';
  $form['#attached']['drupalSettings']['g9']['vertical_mapping'] = $brand_mapping;

  // Get all the enabled types from the 'Save and Update' configuration page.
  $enabled_types = \Drupal::config('g9.save_update.settings')->get('enabled');

  // Filter out only the checked content types.
  $enabled_types = array_filter($enabled_types);

  if (isset($form['field_save_update'])) {
    // Disable access to the field. Note: We cannot simply hide it in the form
    // display because then it is inaccessable here as well.
    $form['field_save_update']['#access'] = FALSE;

    // If the "Save and Update" button is enabled for this node type, add it.
    if (in_array($node->getType(), $enabled_types)) {
      $form['actions'][] = [
        '#type' => 'submit',
        '#access' => TRUE,
        '#value' => t("Save and Update"),
        '#weight' => 20,
        '#submit' => [
          '0' => 'g9_node_save_and_update',
          '1' => '::submitForm',
          '2' => '::save',
        ],
      ];
    }
  }
}

/**
 * Custom submit handler for the "Save and Update" button.
 *
 * @param array $form
 *   The form array.
 * @param Drupal\Core\Form\FormStateInterface $form_state
 *   The form state object.
 */
function g9_node_save_and_update(array &$form, FormStateInterface $form_state) {
  // Set the field value to the current timestamp.
  $form_state->setValue(['field_save_update', 0, 'value'], time());
}

/**
 * Implements hook_form_FORM_ID_alter().
 *
 * @todo Move to g9_user module.
 */
function g9_form_user_login_form_alter(&$form, FormStateInterface $form_state, $form_id) {
  $image = [
    '#type' => 'html_tag',
    '#tag' => 'img',
    '#attributes' => [
      'src' => 'https://assets3.thrillist.com/v1/image/1736955',
      'id' => 'logo',
      'style' => 'width: 150px;',
    ],
  ];
  $image_html = \Drupal::service('renderer')->render($image);
  $form['logo'] = [
    '#type' => 'html_tag',
    '#tag' => 'center',
    '#value' => $image_html,
    '#weight' => -10,
  ];
}
